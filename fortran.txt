! ==============================================================================
! Simulation code for the manuscript: 
! "Strategic Spatiotemporal Vaccine Distribution Increases the Survival Rate in an Infectious Disease like Covid-19"
!
! Copyright (C) 2020 Jens Grauer, CCBY4.0 
! ==============================================================================

MODULE nrtype ! for random number generator
INTEGER, PARAMETER  :: I4B = SELECTED_INT_KIND(9)
INTEGER, PARAMETER  :: I2B = SELECTED_INT_KIND(4)
INTEGER, PARAMETER  :: I1B = SELECTED_INT_KIND(2)
INTEGER, PARAMETER  :: SP = KIND(1.0)
INTEGER, PARAMETER  :: DP = KIND(1.0D0)
INTEGER, PARAMETER  :: SPC = KIND((1.0,1.0))
INTEGER, PARAMETER  :: DPC = KIND((1.0D0,1.0D0))
INTEGER, PARAMETER  :: LGT = KIND(.true.)
END MODULE nrtype


! ==============================================================================
! ==============================================================================

PROGRAM	VACCSTRAT

! All lengths are in units of R_c (= infection radius).
! Time in units of 14/100days (t_D=100).

IMPLICIT NONE
INTEGER                 :: i,j,ncells,Nx,Ny,Np,pretime,simtime,framecount,idum,incells,equil,Ncity
REAL(8)                 :: L,rm,rminwca,rcutoff,dx,dy,D_T,dt,time,epst,epst_attr,&
                           mindestabstand,rinf,inf_prob,maxdisease_time,availvacc,impftime,&
                           epst_attr_eff,epst_eff,A_city,A_citytmp,rmincity,rn,mincitydist,distx,disty,dist
CHARACTER(60)           :: infile,dummy
REAL(8), DIMENSION(:), ALLOCATABLE   :: dxpart,dypart,SIR,disease_time,k_city,R_city,rnrw,Pnrw
REAL(8), DIMENSION(:,:), ALLOCATABLE :: rp,inc,eff_inc,rcity
INTEGER, DIMENSION(:), ALLOCATABLE :: ncounter,ncounter_new
INTEGER, DIMENSION(:,:), ALLOCATABLE :: cellcounter,nindex,nindex_new,ccounter_normal,ccounter_infected
INTEGER, DIMENSION(:,:,:), ALLOCATABLE :: cellindex,cindex_normal


! SPECIFY INPUT PARAMETERS

  call getarg(1,infile)
  open(21, file = infile, action = "read", status = "old")
    read(21,*), Np,dummy                        ! number of agents
    read(21,*), L,dummy                         ! length of system
    read(21,*), dt,dummy                        ! time step size
    read(21,*), epst,dummy                      ! amplitude WCA-potential
    read(21,*), epst_attr,dummy                 ! attractive potential
    read(21,*), idum,dummy                      ! seed for random number generator
    read(21,*), pretime,dummy                   ! total equilibration time 
    read(21,*), simtime,dummy                   ! total simulation time (after equilibration)
    read(21,*), D_T, dummy                      ! diffusion coefficient
    read(21,*), mindestabstand,dummy            ! minimum distance
    read(21,*), inf_prob, dummy                 ! probability infection
    read(21,*), maxdisease_time                 ! duration of disease
    read(21,*), rinf                            ! infection radius
    read(21,*), impftime                        ! onset of vaccination
    read(21,*), availvacc                       ! available vaccine
    read(21,*), incells                         ! incells
    read(21,*), A_city                          ! attraction from 'cities'
    read(21,*), Ncity                           ! number of 'cities'
    read(21,*), mincitydist                     ! minimum distance between 'cities'
  close(21)

  
  ! initial conditions
  rm      = mindestabstand+0.1                  !particle distance (social distancing)
  rcutoff = rm                                  !cutoff radius
  ncells  = 100!NINT(L/(rm))					!number of cell in cell list (rm=2R<dx_wca)
  rminwca = 0.8*rm
  
  epst_eff = 0
  epst_attr_eff = 0
  rmincity = 0
  
  dx = 1.D0 
  dy = dx
  Nx = NINT(L/dx)                               !spatial resolution
  Ny = Nx            
  
ALLOCATE(dxpart(Np),dypart(Np),cellcounter(ncells,ncells),rp(2,Np),&
		 cellindex(ncells,ncells,Np),ncounter(Np),nindex(Np,Np),SIR(Np),&
		 disease_time(Np),ncounter_new(Np),nindex_new(Np,Np),&
		 cindex_normal(incells,incells,Np),ccounter_infected(incells,incells),&
		 ccounter_normal(incells,incells),inc(incells,incells),&
		 eff_inc(incells,incells),rcity(2,Ncity),R_city(Ncity),&
		 k_city(Ncity),rnrw(26),Pnrw(26))
		 
  disease_time(:)=0
  dxpart(:)=0                                
  dypart(:)=0
  ncounter(:) = 0
  nindex(:,:) = 0
  ncounter_new(:) = 0
  nindex_new(:,:) = 0

!===============================================================================
! Start from random configuration  
  dist=0
  do while (dist.lt.mincitydist)
	do i=1,Ncity
		rcity(1,i) = (L-2*dx)*rando(idum)+dx
		rcity(2,i) = (L-2*dx)*rando(idum)+dx
	enddo
	dist=L
	do i=1,Ncity
	  do j=1,Ncity
	   if (i.ne.j) then
	    distx = abs(rcity(1,i)-rcity(1,j))
	    disty = abs(rcity(2,i)-rcity(2,j))
	    if (distx.gt.L/2) then
			distx = L - distx
		endif
		if (disty.gt.L/2) then
			disty = L - disty
		endif
		if (sqrt(distx**2+disty**2).le.dist) then
			dist = sqrt((rcity(1,i)-rcity(1,j))**2+(rcity(2,i)-rcity(2,j))**2)
		endif
	   endif
	  enddo
	enddo
  enddo
  
  do i=1,size(rnrw(:))
	rnrw(i) = 20+(i-1)*2
  enddo
  do i=1,size(rnrw(:))
    Pnrw(i) = 1/rnrw(i)*1/log(rnrw(26)/rnrw(1))
  enddo  
  
  R_city(:)=0
  do j=1,Ncity
	do while (R_city(j).eq.0)
		rn=rando(idum)
		do i=1,size(Pnrw(:))
			if ((rn.le.Pnrw(i)).and.(rn.gt.Pnrw(26))) then
				R_city(j)=rnrw(i)
			endif
		enddo
    enddo
    k_city(j) = 1/(2*R_city(j)**2)
  enddo
!-----------------------------------------------------------------------
!initial particle position
  do i=1,Np
	rp(1,i) = (L-2*dx)*rando(idum)+dx
	rp(2,i) = (L-2*dx)*rando(idum)+dx      
  enddo
!----------------------------------------------------------------------- 
!Equilibrate
  time=0.D0
  equil = 1
  A_citytmp = A_city
  do while (time < pretime)
	if (time < pretime/4) then
		A_city = 10*A_citytmp
	else
		A_city = A_citytmp
	endif
	call assigncells
	call calcforces
	call diffusion
	call move
	call boundarycondition
    time = time + dt
  enddo
  equil = 0  
   
  !open(22, file = 'equil_traj.txt' , action = "read", status= "old")
  !      do i=1,Np
  !           read(22,*), rp(1,i),rp(2,i)
  !      enddo
  !close(22)

!initial number of infections
  SIR(:)=1
  SIR(1:Np/2000)=2  
  
  framecount=0
  time=0.D0
! Do simulation run
  do while (time < simtime)
    if (time.gt.0) then
      epst_eff=epst
      epst_attr_eff=epst_attr
    endif
    call assigncells
    call calcforces
    call diffusion
    call disease_progression
    if (time.gt.impftime) then
    	call vaccination
    endif
    call move
    call boundarycondition    
    if (modulo(time,2D0).lt.dt) then
      call writetrajectory(framecount)
      framecount=framecount+1
    endif
    time = time + dt
	
  enddo


CONTAINS

!==============================================================================

  SUBROUTINE move 
  IMPLICIT NONE
   
    rp(1,:) = rp(1,:) + dxpart(:) 
    rp(2,:) = rp(2,:) + dypart(:)
    
    dxpart(:)=0                                
    dypart(:)=0
    ncounter = ncounter_new
    nindex = nindex_new
    ncounter_new(:) = 0
    nindex_new(:,:) = 0
    
  ENDSUBROUTINE move

!-------------------------------------------------------------------------------

SUBROUTINE disease_progression
  IMPLICIT NONE
  INTEGER			:: ip

  do ip=1,Np
    if (SIR(ip).eq.2) then
		disease_time(ip)=disease_time(ip)+dt
		if (disease_time(ip).ge.maxdisease_time) then
			!survival probability (mild symptoms)
			if (rando(idum).le.0.01) then
                SIR(ip)=6
            else
				SIR(ip)=4
            endif
		endif  
	elseif (SIR(ip).eq.3) then
		disease_time(ip)=disease_time(ip)+dt
		if (disease_time(ip).ge.maxdisease_time) then
			!survival probability  (significant symptoms)
			if (rando(idum).le.0.035) then
				SIR(ip)=6
			else
				SIR(ip)=4
			endif
		endif
	elseif (SIR(ip).eq.4 .or. SIR(ip).eq.6) then
	    disease_time(ip)=disease_time(ip)+dt
	endif
	!Quarantine
	if (((SIR(ip).eq.3) .and. (disease_time(ip).ge.maxdisease_time/3)) .or. (SIR(ip).eq.6)) then  !.or.(SIR(ip).eq.4).or.(SIR(ip).eq.5)
		dxpart(ip)=0            
		dypart(ip)=0
    endif
  enddo
  
  ENDSUBROUTINE disease_progression

!-------------------------------------------------------------------------------

  SUBROUTINE assigncells
  IMPLICIT NONE
  INTEGER			::	i, j, ii, jj, ip

  ! Assign particles to cells based on their coordinates; particle indices
  ! in each cell are sorted from low to high.

  cellcounter(:,:) = 0
  cellindex(:,:,:) = 0
  ccounter_infected(:,:) = 0
  ccounter_normal(:,:) = 0
  cindex_normal(:,:,:) = 0
  do ip=1,Np
	ii = ceiling(rp(1,ip)*ncells/(L))
	jj = ceiling(rp(2,ip)*ncells/(L))
	cellcounter(ii,jj) = cellcounter(ii,jj) + 1
	cellindex(ii,jj,cellcounter(ii,jj)) = ip
	i = ceiling(rp(1,ip)*incells/(L))
	j = ceiling(rp(2,ip)*incells/(L))   
	if ((SIR(ip).eq.2).or.(SIR(ip).eq.3)) then
		ccounter_infected(i,j)=ccounter_infected(i,j)+1
	elseif (SIR(ip).eq.1) then
		ccounter_normal(i,j)=ccounter_normal(i,j)+1
		cindex_normal(i,j,ccounter_normal(i,j)) = ip 
	endif
  enddo
  ENDSUBROUTINE assigncells

!-----------------------------------------------------------------------------

  SUBROUTINE vaccination
  IMPLICIT NONE
  INTEGER			   :: icell,jcell,ip,icount,i,j,ii,jj,re,ic,jc
  REAL(8)			   :: sum_inc,prob,rest,maxinc
  INTEGER, DIMENSION(SIZE(SHAPE(inc))) :: maxinfloc 
  REAL(8), DIMENSION(incells,incells) :: inc_cp
  
  sum_inc=0
  do icell=1,incells
	do jcell=1,incells
	  if (ccounter_infected(icell,jcell).gt.0) then
		!bi-linear incidence rate 
		inc(icell,jcell)=ccounter_normal(icell,jcell)*ccounter_infected(icell,jcell)
	  else
	    inc(icell,jcell)=0
	  endif
    enddo		
  enddo
  

!  do re=1,10
!  inc_cp=inc
!  do i=1,incells
!   do j=1,incells
!     do ii=i-1,i+1
!       do jj=j-1,j+1
!         if (ii.eq.0) then
!			ic=incells
!		 elseif (ii.eq.incells+1) then
!			ic=1
!		 else
!		    ic=ii
!		 endif
!		 if (jj.eq.0) then
!			jc=incells
!		 elseif (jj.eq.incells+1) then
!			jc=1
!		 else
!		    jc=jj
!		 endif
!		 inc(i,j) = inc(i,j)+inc_cp(ic,jc)
!	   enddo
!	 enddo
!   enddo
!  enddo
!  enddo
!  
!  maxinfloc=maxloc(inc(:,:))
!  maxinc=inc(maxinfloc(1),maxinfloc(2))
!  
!  do icell=1,incells
!	do jcell=1,incells
!	  if (inc(icell,jcell).le.0.98*maxinc) then
!	    inc(icell,jcell)=0
!	  endif
!	enddo
!  enddo
  
  eff_inc=inc
  sum_inc=sum(eff_inc)
 
  rest=0
  
    eff_inc(:,:)=eff_inc(:,:)/sum_inc*availvacc
    do icell=1,incells
  	  do jcell=1,incells
		if (eff_inc(icell,jcell).gt.ccounter_normal(icell,jcell)) then
			rest=rest+eff_inc(icell,jcell)-ccounter_normal(icell,jcell)
		endif
		do icount=1,ccounter_normal(icell,jcell)
		    ip = cindex_normal(icell,jcell,icount)
			if (rando(idum).le.eff_inc(icell,jcell)/ccounter_normal(icell,jcell)) then
				SIR(ip)=5
			endif
		enddo
	  enddo
    enddo
   	
    if (rest.gt.0) then
		prob=rest/sum(ccounter_normal)
		do ip=1,Np
			if (SIR(ip).eq.1) then
				if (rando(idum).le.prob) then
					SIR(ip)=5
				endif
			endif
		enddo
     endif

  ENDSUBROUTINE vaccination

!-------------------------------------------------------------------------------

  SUBROUTINE calcforces
  IMPLICIT NONE
  INTEGER					:: i,j,ii,jj,icell,jcell,ip,jp,icount,jcount,icity
  REAL(8)					:: r,r2,xij,yij,xforce,yforce,rforce,rmin


  ! Convention: xij = xi-xj, yij = yi-yj, zij = zi-zj; Fij = -Fji.

  dxpart(:)=0                                
  dypart(:)=0  
  ! loop over cells
	do i=1,ncells
		do j=1,ncells
			do icount=1,cellcounter(i,j)
				rmin=L
				ip = cellindex(i,j,icount)
				do ii=i-1,i+1
					do jj=j-1,j+1
						if (ii.eq.0) then 
							icell=ncells 
						elseif (ii.eq.ncells+1) then 
							icell=1
						else
							icell=ii
						endif
								if (jj.eq.0) then 
							jcell=ncells 
						elseif (jj.eq.ncells+1) then
							jcell=1 
						else
							jcell=jj
						endif
						do jcount=1,cellcounter(icell,jcell)
							jp = cellindex(icell,jcell,jcount)
							if (ip.ne.jp) then
								xij = rp(1,ip) - rp(1,jp)
								yij = rp(2,ip) - rp(2,jp)
  
								if (i.eq.1 .and. icell.eq.ncells) then 
									xij = xij + L  
								elseif (i.eq.ncells .and. icell.eq.1) then
									xij = xij - L  
								endif 
								if (j.eq.1 .and. jcell.eq.ncells) then 
									yij = yij + L  
								elseif (j.eq.ncells .and. jcell.eq.1) then
									yij = yij - L  
								endif 
  
								r2 = xij**2 + yij**2
								r = sqrt(r2)
											
								!count neighbours - social distancing
								if (r.le.1.5*mindestabstand) then
									ncounter_new(ip) = ncounter_new(ip) + 1
									nindex_new(ip,ncounter_new(ip)) = jp
									if (r.le.rmin) then
										nindex_new(ip,ncounter_new(ip)) = nindex_new(ip,1)
										nindex_new(ip,1) = jp
										rmin=r
									endif
								endif
										  
								!Infection
								if ((equil.eq.0) .and. (r.le.rinf) .and. ((SIR(ip).eq.2).or.(SIR(ip).eq.3)) .and. (SIR(jp).eq.1)) then
									if (rando(idum).le.inf_prob) then
										if (rando(idum).le.0.75) then
											SIR(jp)=2
										else
											SIR(jp)=3
										endif
									endif
								endif
											
								!Potential
								if ((r.le.rcutoff) .and. (jp.ne.nindex(ip,1).or.(SIR(jp).eq.3))) then
									!WCA-pot
									if (r.ge.rminwca) then
										rforce=-12*((rm**6)/(r**7) - (rm**12)/(r**13))    
									else
										rforce=-12*((rm**6)/(rminwca**7) - (rm**12)/(rminwca**13))
									endif
									xforce = xij*rforce/r
									yforce = yij*rforce/r
									dxpart(ip) = dxpart(ip) + dt*epst_eff*xforce
									dypart(ip) = dypart(ip) + dt*epst_eff*yforce
								endif
								
								if ((r.le.mindestabstand) .and. (jp.eq.nindex(ip,1)).and.(SIR(jp).ne.6)) then
									!attractive part of WCA-pot for pair-attraction
									if (r.ge.rminwca) then
										rforce=-12*((rm**6)/(r**7))     
									else
										rforce=-12*((rm**6)/(rminwca**7))
									endif
									xforce = xij*rforce/r
									yforce = yij*rforce/r
									dxpart(ip) = dxpart(ip) + dt*epst_attr_eff*xforce
									dypart(ip) = dypart(ip) + dt*epst_attr_eff*yforce
								endif
							endif
						enddo
					enddo
				enddo
				!attraction from City
				do icity=1,size(rcity(1,:))
					xij = rp(1,ip) - rcity(1,icity)
					yij = rp(2,ip) - rcity(2,icity)
					if (xij.gt.L/2) then 
						xij = L - xij  
					elseif (xij.lt.-L/2) then
						xij = L + xij
					endif
					if (yij.gt.L/2) then 
						yij = L - yij  
					elseif (yij.lt.-L/2) then
						yij = L + yij
					endif
					r2 = xij**2 + yij**2
					r = sqrt(r2)
					if (r.ge.rmincity) then
						rforce=-2*A_city*k_city(icity)*r*exp(-k_city(icity)*r**2)     
					else
						rforce=-2*A_city*k_city(icity)*rmincity*exp(-k_city(icity)*rmincity**2)
					endif
					xforce = xij*rforce/r 
					yforce = yij*rforce/r 
					dxpart(ip) = dxpart(ip) + dt*xforce
					dypart(ip) = dypart(ip) + dt*yforce
				enddo
			enddo
		enddo
	enddo
   
  ENDSUBROUTINE calcforces

!------------------------------------------------------------------------------------

  SUBROUTINE diffusion 
  IMPLICIT NONE
  INTEGER			:: ip
  REAL(4)			:: harvest
  
  do ip=1,Np
   call gasdev(harvest)
   dxpart(ip) = dxpart(ip) + sqrt(2*D_T)*sqrt(dt)*harvest
   call gasdev(harvest)
   dypart(ip) = dypart(ip) + sqrt(2*D_T)*sqrt(dt)*harvest
  enddo 
   
 ENDSUBROUTINE diffusion
 
!--------------------------------------------------------------------------------

  SUBROUTINE boundarycondition
  IMPLICIT NONE
  INTEGER 			:: i
  
  do i=1,Np
  	if (rp(1,i).gt.L) then
		rp(1,i) = rp(1,i) - L
	elseif (rp(1,i).lt.0) then
		rp(1,i) = rp(1,i) + L
	endif
	if (rp(2,i).gt.L) then
		rp(2,i) = rp(2,i) - L
	elseif (rp(2,i).lt.0) then
		rp(2,i) = rp(2,i) + L
	endif
  enddo
  
  ENDSUBROUTINE boundarycondition
! ------------------------------------------------------------------------------

  SUBROUTINE writetrajectory(framecount)
  IMPLICIT NONE 
  INTEGER           :: framecount
  character(len=8)  :: fmt
  character(len=7)  :: x1
  REAL(8), DIMENSION(4,Np) :: dataset

  fmt = '(I4.4)' ! an integer of width 4 with zeros at the left
  write (x1,fmt) framecount ! converting integer to string using an 'internal file'
 
  dataset(1,:)=SIR(:)
  dataset(2,:)=disease_time(:) 
  
  open(24,file= "traj_" // trim(x1) // ".dat", action= "write", status = "replace")
  do i=1,Np
    write(24,*), rp(1,i),rp(2,i)
  enddo
  close(24)

  open(25,file= "data_" // trim(x1) // ".dat", action= "write", status = "replace")
  do i=1,Np
    write(25,*), dataset(1,i),dataset(2,i)
  enddo
  close(25)
  		
  END SUBROUTINE writetrajectory
  
!---------------------------------------------------------------------------------


! RANDOM NUMBER GENERATOR FROM "NUMERICAL RECIPES"
!
! Fast & accurate ran1_s(harvest) random number generator from NR (uses several
! modules from NR) including gasdev generator for Gaussian random distribution
! with zero mean and unit variance.

  FUNCTION rando(idum) ! random number from uniform distribution ("ran1_s")
  IMPLICIT NONE
  INTEGER, PARAMETER :: K4B=selected_int_kind(9)
  INTEGER(K4B), INTENT(INOUT) :: idum
  REAL :: rando
  INTEGER(K4B), PARAMETER :: IA=16807,IM=2147483647,IQ=127773,IR=2836
  REAL, SAVE :: am
  INTEGER(K4B), SAVE :: ix=-1,iy=-1,k
  if (idum <= 0 .or. iy < 0) then
    am=nearest(1.0,-1.0)/IM
    iy=ior(ieor(888889999,abs(idum)),1)
    ix=ieor(777755555,abs(idum))
    idum=abs(idum)+1
  end if
  ix=ieor(ix,ishft(ix,13))
  ix=ieor(ix,ishft(ix,-17))
  ix=ieor(ix,ishft(ix,5))
  k=iy/IQ
  iy=IA*(iy-k*IQ)-IR*k
  if (iy < 0) iy=iy+IM
  rando=am*ior(iand(IM,ieor(ix,iy)),1)
  END FUNCTION rando
 
  ! Generates normally distributed random number with zero mean and unit
  ! variance, uses ran1.
 
  SUBROUTINE gasdev(harvest) ! random number from Gaussian distribution
  USE nrtype
  IMPLICIT NONE
  REAL(SP), INTENT(OUT) :: harvest
  REAL(SP) :: rsq,v1,v2
  REAL(SP), SAVE :: g
  LOGICAL, SAVE :: gaus_stored=.false.
  if (gaus_stored) then
    harvest=g
    gaus_stored=.false.
  else
    do
      v1 = rando(idum)
      v2 = rando(idum)
      v1=2.0_sp*v1-1.0_sp
      v2=2.0_sp*v2-1.0_sp
      rsq=v1**2+v2**2
      if (rsq > 0.0 .and. rsq < 1.0) exit
    end do
    rsq=sqrt(-2.0_sp*log(rsq)/rsq)
    harvest=v1*rsq
    g=v2*rsq
    gaus_stored=.true.
  end if
  if (harvest .eq. 0.) harvest =  10E-10 ! avoid zeros
  END SUBROUTINE gasdev
! ------------------------------------------------------------------------------

END PROGRAM VACCSTRAT